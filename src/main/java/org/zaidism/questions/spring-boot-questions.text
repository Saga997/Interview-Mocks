Spring boot interview questions (Source: https://medium.com/@javatechie/spring-boot-in-depth-interview-faqs-62edf6cda4e7)
https://www.youtube.com/playlist?list=PLVz2XdJiJQxwS8FyWnWyKyfILxHPLsiro
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Why will you choose Spring Boot over Spring Framework?
- Dependency Resolution / Avoid Version conflict
- Avoid additional configuration
- Embedded Tomcat, Jetty (no need to deploy WAR files)
- Provide production-ready features such as metrics, health checks (actuators)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What all spring boot starter you have used or what all module you have worked on ?

 - spring-boot-starter-web
 - spring-boot-starter-data-jpa
 - spring-boot-starter-security
 - spring-boot-starter-cache
 - spring-boot-starter-cloud
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How will you run your Spring Boot application ?

    1. mvn spring-boot:run
    2. mvn clean install
       java -jar target/your-application.jar
    3. Run the main class with @SpringBootApplication.

 - When we run spring boot application it, spring does not implicitly creates jar file for your project instead it runs .class file for your main spring class annotated
   with @SpringBootApplication.
 - When we do mvn clean install it actually generates the jar file inside the target folder
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is the purpose of the @SpringBootApplication annotation in a Spring Boot application ?

- Combines Annotations:
  - Meta-annotation that combines `@Configuration`, `@EnableAutoConfiguration`, and `@ComponentScan`.

- Configuration:
  - Indicates the class is a configuration class.
  - Allows definition of beans and configuration settings.
  - On application start up loads all the configuration classes

- Auto-Configuration:
  - Enables Spring Boot's automatic configuration.
  - Configures the application based on dependencies and classpath.

- Component Scanning:
  - Activates component scanning for Spring components (`@Component`, `@Service`, `@Repository`, etc.).
  - Automatically discovers and registers Spring beans.
  - It scan current class and it's subpackages to discovers and registers Spring beans.

- Main Application Class:
  - Typically used on the class containing the `main` method.
  - Serves as the entry point, bootstrapping the Spring Boot application.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
can I directly use @EnableAutoConfiguration, @ComponentScan & @Configuration annotation in my main class , instead of using @SpringBootApplication annotation,
 if yes will my application work as expected ?

 - Yes we can use directly these annotation instead of @SpringBootApplication. There will be no impact. Below are the examples of it

 @Configuration
 @EnableAutoConfiguration
 @ComponentScan
 @Import({MyAdditionalConfiguration.class, AnotherConfiguration.class})
 public class MySpringBootApp {

     public static void main(String[] args) {
         // Your application logic here
     }
 }

  @Configuration
  @EnableAutoConfiguration
  @ComponentScan
  public class MySpringBootApp {

      public static void main(String[] args) {
          // Your application logic here
      }
  }

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Auto configuration in spring boot ?

Auto-Configuration in Spring Boot:

- Automated Configuration:
  - Spring Boot's auto-configuration automatically configures the application based on its dependencies and the classpath.
  - Reducing the need for explicit configuration.

- Default Settings:
  - Provides sensible default settings for various components, reducing the burden on developers to configure them manually.

- Annotation: `@EnableAutoConfiguration`:
  - Applied at the class level to enable auto-configuration.
  - Typically included in the `@SpringBootApplication` annotation.

- Example 1 - DataSource Configuration:
  - If `spring-boot-starter-data-jpa` is in the classpath, Spring Boot auto-configures a `DataSource` bean.
  - No need for explicit configuration unless custom settings are required.

  // Main class with @SpringBootApplication
  @SpringBootApplication
  public class MySpringBootApp {

      public static void main(String[] args) {
          // Your application logic here
      }
  }

  // No explicit DataSource configuration required
  @Entity
  public class MyEntity {
      // Entity definition
  }

- Example 2- Web Server Configuration:

  If spring-boot-starter-web is in the classpath, Spring Boot auto-configures an embedded web server (e.g., Tomcat, Jetty).
  Developers don't need explicit configuration for basic web server setup.

- Customization:
  - Developers can override auto-configured settings or provide custom configurations when needed.

- Simplifies Development:
  - Developers can focus on application-specific configurations rather than boilerplate setup.

In summary, Spring Boot's auto-configuration simplifies development by providing sensible defaults and automatically configuring components based on the project's
dependencies and classpath. It follows the convention over configuration principle, reducing the need for explicit configuration.


- Understand which classes and configurations are auto-configured by Spring Boot when adding the `spring-boot-starter-web` dependency or any other dependencies.

 Steps:
   - Add the `spring-boot-starter-web` dependency to the project.
   - Enable debug mode in the `application.properties` file by adding `debug=true`. (#################)

 Execution:d
   - Start the application.
   - During startup, Spring Boot evaluates conditions and identifies positive and negative matches for auto-configuration.

 Analysis:
   - Check the logs for positive matches (configurations enabled by default) and negative matches (configurations not enabled).
   - Example: Jackson Auto Configuration is mentioned as a positive match, indicating that it will be auto-configured for the application.

 Outcome:
   - Understand which configurations Spring Boot automatically enables based on the project's dependencies and classpath.

Keep in mind that the actual details of positive and negative matches will be visible in the debug logs during application startup.
The example highlights the Jackson Auto Configuration as one of the positive matches.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How can you disable a specific auto-configuration class in Spring Boot ?

 - To disable a specific auto-configuration class using annotations, you can use the `@SpringBootApplication` annotation along with `exclude` attribute. Here's how you can do it:

        @SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
        public class MySpringBootApp {

            public static void main(String[] args) {
                SpringApplication.run(MySpringBootApp.class, args);
            }
        }
 - In this example, the `@SpringBootApplication` annotation includes the `exclude` attribute, where you specify the auto-configuration class you want
   to exclude (`DataSourceAutoConfiguration` in this case). This approach allows you to disable specific auto-configurations directly in your main application class.

        or

   - Using `application.properties`:

   - spring.autoconfigure.exclude=org.example.ExcludedAutoConfiguration

   - Replace `org.example.ExcludedAutoConfiguration` with the fully qualified name of the auto-configuration class you want to exclude.

   - For example, if you want to disable the `DataSourceAutoConfiguration` class, which is responsible for configuring a `DataSource` based on the classpath, you can do the following:

   - spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration

   - This disables the auto-configuration specifically for `DataSourceAutoConfiguration`.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How can you customize the default configuration in Spring Boot like port no?


 In Spring Boot, you can customize default configurations, such as the server port, by using properties. These properties can be defined in the application.properties
 or application.yml file or overridden programmatically in your Spring Boot application. Here's how you can customize the default server port:

 Using application.properties or application.yml:

 Add the following property to your application.properties or application.yml file:

 server.port=your-desired-port
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How Spring boot run() method works internally ?

 - Load env and properties from properties file
 - Creates ApplicationContext
 - Register Bean into Context
 - Start up embedded tomcat container to run the jar/war

Here's a concise breakdown of how the `run()` method works internally in Spring Boot:

- ApplicationContext Creation:
  - The `run()` method initializes and creates the ApplicationContext.
  - Before creating ApplicationContext inside run method it loads environment based the configuration provided in prop or yaml file
  - ApplicationContext is a container that holds and manages beans (objects) for the application.
  - While creating ApplicationContext it checks application type as well whether it is a WebApplication or some other type of application in spring

- Bean Registration:
  - Beans (components of the application) are registered with the ApplicationContext through component scan.
  - These can be user-defined beans or Spring Boot's auto-configured beans.

- Starting Embedded Tomcat Container:
  - If the application is a web application, Spring Boot starts an embedded Tomcat container.
  - This container is responsible for handling HTTP requests and serving the application.


In summary, the `run()` method in Spring Boot performs the essential steps of setting up the ApplicationContext, registering beans, starting an embedded Tomcat container
(if it's a web application), executing the application logic, and preparing for a graceful shutdown.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Command line runner in spring boot ?

    - In Spring Boot, a CommandLineRunner is an interface that provides a way to execute code after the Spring Boot application has started.
      It is a part of the Spring Boot application lifecycle and allows developers to run custom logic or tasks that need to be executed once
      the application context has been fully initialized.

    - To use CommandLineRunner, you implement the interface in a Spring Bean or component.
    - The run method contains the custom logic that you want to execute after the application starts.
    - CommandLineRunner is a functional interface

    import org.springframework.boot.CommandLineRunner;
    import org.springframework.stereotype.Component;

    @Component
    public class MyCommandLineRunner implements CommandLineRunner {

        @Override
        public void run(String... args) throws Exception {
            // Custom logic to be executed after the application starts
            System.out.println("Executing command line runner");
        }
    }
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Can you explain the purpose of Stereotype annotations in the Spring Framework ?

Stereotype annotations in the Spring Framework are used to indicate the roles of annotated classes in the application.
These annotations help the Spring container to understand and manage these classes appropriately.

Here are five commonly used Stereotype annotations in Spring:
    1. @Controller:
       - Purpose: Marks a class as a Spring MVC controller.
       - Usage: Used in the presentation layer to handle HTTP requests and generate responses.
    2. @RestController:
       - Purpose: Specialization of `@Controller` for RESTful web services. It combines `@Controller` and `@ResponseBody`.
       - Usage: Used to create RESTful web services that return JSON or XML responses.
    3. @Service:
       - Purpose: Marks a class as a service bean in the business layer.
       - Usage: Used to define business logic and transactional methods.
    4. @Repository:
       - Purpose: Marks a class as a Data Access Object (DAO) component, typically for database operations.
       - Usage: Used in the persistence layer to interact with databases or other data sources.
    5. @Component:
       - Purpose: Generic stereotype annotation for any Spring-managed component.
       - Usage: Used when no more specific stereotype annotation (e.g., `@Controller`, `@Service`) is suitable.

These Stereotype annotations help the Spring container identify and manage different types of components within the application, facilitating dependency injection
and overall application structure. They play a crucial role in achieving a well-organized and modular Spring-based application architecture.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How can you define bean in spring framework ?

In Spring Framework, a bean is an object that is managed by the Spring IoC (Inversion of Control) container. Beans are typically Java objects that are instantiated, assembled,
and managed by the Spring container. In a Spring application, you can define beans using the `@Bean` annotation within a configuration class annotated with `@Configuration`.

    Here's an example of defining a bean using `@Bean` in a Spring configuration class:

    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;

    @Configuration
    public class AppConfig {

        @Bean
        public MyBean myBean() {
            return new MyBean();
        }
    }

    In this example:

    - `@Configuration` indicates that the class contains bean definitions.
    - `@Bean` is used on a method (`myBean()` in this case) to declare a bean. The method name (`myBean`) serves as the bean identifier.
    - The method returns the type of the bean (`MyBean`), and the instance returned by the method becomes the bean managed by the Spring container.

    You can then use this bean in other parts of your application by injecting it through constructor injection, method injection, or field injection. For example:

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;

    @Service
    public class MyService {

        private final MyBean myBean;

        @Autowired
        public MyService(MyBean myBean) {
            this.myBean = myBean;
        }

        // Rest of the service logic using myBean
    }

Here, the `MyService` class uses constructor injection to receive the `MyBean` instance, which is provided by the Spring container.
Note: The `@ComponentScan` annotation or XML configuration is typically used to enable component scanning and discover `@Configuration` classes and `@Component`-annotated classes.
This allows Spring to automatically detect and register beans in the application context.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is dependency injection ?

- Manual Object Creation:
  - Before Spring, in Java, programmers had to manually create objects. For example, if the class `Laptop` needed an object of the `Processor` class,
    it had to be created inside the `Laptop` class.

- Tight Coupling Issue:
  - This manual approach resulted in tight coupling, making the application less flexible and harder to maintain.

- Spring's Solution - Dependency Injection (DI):
  - Spring provides a solution through Dependency Injection.
  - With DI, Spring automatically provides the `Processor` object to the `Laptop` class without the programmer having to create it explicitly.

- Inversion of Control (IoC):
  - DI is a form of Inversion of Control (IoC), where control of object creation is given to Spring.
  - The IoC container in Spring takes care of injecting dependencies at runtime.

- IoC Containers in Spring:
  - Spring has two types of IoC containers: `BeanFactory` and `ApplicationContext`.
  - These containers manage the lifecycle of objects and handle the injection of dependencies, promoting a more modular and maintainable design.

In summary, Dependency Injection in Spring eliminates the need for manual object creation, promoting a loosely coupled and more maintainable application design.
The Inversion of Control principle is implemented through Spring's IoC containers, providing flexibility and ease of development.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How many ways we can perform dependency injection in spring or spring boot ? (fields, contractor, setter)

- Field Injection:
  - Dependencies are injected directly into fields using `@Autowired` annotation.
  - Example: `@Autowired private MyDependency myDependency;`

- Constructor Injection:
  - Dependencies are injected through the constructor of the dependent class.
  - Preferred method for dependency injection.
  - Example:

    @Autowired
    public MyClass(MyDependency myDependency) {
        this.myDependency = myDependency;
    }

- Setter Injection:
  - Dependencies are injected through setter methods of the dependent class.
  - Example:

    @Autowired
    public void setMyDependency(MyDependency myDependency) {
        this.myDependency = myDependency;
    }

- Method Injection:
  - Dependencies are injected through methods other than the constructor or setters.
  - Example:

    @Autowired
    public void init(MyDependency myDependency) {
        this.myDependency = myDependency;
    }
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
where you would choose to use setter injection over constructor injection, and vice versa ? (immutable, partial injection)

- Constructor Injection:
  - Preferred for mandatory dependencies.
  - Better for creating immutable objects.
  - Promotes better encapsulation.
  - circular dependencies error (Example: Two bean autowired in each other's classes with constructor injection will give error during run time)

- Setter Injection:
  - Suitable for optional or mutable dependencies.
  - Allows for partial injection or changing dependencies after object creation.
  - Circular dependencies error can be bypass/resolved (Example: Two bean autowired lazily using @Lazy each other's classes with setter injection will not give error during run time)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Can you provide an example of a real-world use case where @PostConstruct is particularly useful? (preprocessing)

- In a Spring application, you may have a bean responsible for setting up a database connection pool. Use @PostConstruct to perform tasks like initializing
  the connection pool, ensuring it's ready for use when the application starts.

- In this case, @PostConstruct ensures that the database connection pool is initialized once the bean is constructed, avoiding issues with uninitialized
  connections during application startup.

- `CommandLineRunner`s run() method is specifically for tasks related to command line processing after the application context is initialized.
- `@PostConstruct` is for general bean initialization tasks, ensuring that a method is called just after the bean is constructed and dependencies are injected.

While `CommandLineRunner` is more geared towards command line-related tasks, `@PostConstruct` is part of the broader bean lifecycle and can be used for any initialization
logic needed for a bean.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How can we dynamically load values in a Spring Boot application? //@Value Environment class

   @Value Annotation:
   - Use `@Value` to inject values directly into Spring beans.
   - Values can come from properties files, environment variables, etc.

   Example:

   @Value("${my.property}")
   private String myProperty;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Can you explain the key differences between YML and properties files, and in what scenarios you might prefer one format over the other?

YAML (YML):
- Human-readable, indentation-based syntax.
- Supports complex data structures like lists and maps.
- Easier to read and write for complex configurations.

Properties File (`.properties`):
- Simple key-value pairs.
- Limited to flat, string-based configuration.
- Widely used in legacy and simple configuration scenarios.

Scenarios:
- YAML (YML):
  - Preferred for complex configurations.
  - Readability is crucial.
  - Spring Boot application.yml is often used.

- Properties File:
  - Suitable for simple, flat configurations.
  - Legacy systems or tools that expect `.properties` format.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is the difference between yml & YAML ?
 -No difference.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
If I will configure same values in both properties then which value will be load in spring boot OR Who will load first properties or yml file ?

 - properties file gets loaded first.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to load External Properties in Spring Boot ? (spring.config.import)

In Spring Boot, external properties can be loaded using the spring.config.import property. This property allows you to specify additional configuration files to be loaded,
extending or overriding the properties defined in the default application.properties or application.yml.

spring.config.import=classpath:custom-config.properties
spring.config.import=file:/path/to/custom-config.properties


spring:
  config:
    import: classpath:custom-config.yml

spring:
  config:
    import: classpath:custom-config.yml,file:/path/to/another-config.properties

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to map or bind config properties to java Object ? (@ConfigurationProperties(prefix="")

- For instance, let’s assume we want to send emails using the Gmail SMTP server:
      gmail:
            smtp:
                host: smtp.gmail.com
                port: 587
                username: admin
                password: P@ssW@rd


- @Configuration
  @ConfigurationProperties(prefix = "app.gmail.smtp")
  @Data
  @NoArgsConstructor
          public class GmailSmtpServer {
              private String host;
              private int port;
              private String username;
              private String password;
          }

As we can see, @ConfigurationProperties provides the prefix attribute. It denotes the starting point of the properties binding.
For example, Spring Boot will map app.gmail.smtp.host property to host variable.
Spring Boot relies on setters to do the all the heavy lifting of the mapping. This is why we define them for each field using @Data.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How will you resolve bean dependency ambiguity ?

Suppose you have an interface called OrderRepo implemented by two classes: OrderRepoImpl1 and OrderRepoImpl2. If you try to autowire the OrderRepo interface without specifying
which implementation to use, Spring will throw an run time error due to ambiguity.

Here's an example:

    public interface OrderRepo {
        // Interface methods
    }

    @Component("orderRepoImpl1")
    public class OrderRepoImpl1 implements OrderRepo {
        // Implementation of OrderRepo
    }

    @Component("orderRepoImpl2")
    public class OrderRepoImpl2 implements OrderRepo {
        // Implementation of OrderRepo
    }

Now, when you autowire the OrderRepo interface in another class, you can use @Qualifier to specify which implementation to inject:

    @Component
    public class SomeService {

        private final OrderRepo orderRepo;

        @Autowired
        public SomeService(@Qualifier("orderRepoImpl1") OrderRepo orderRepo) {
            this.orderRepo = orderRepo;
        }

        // Other methods using orderRepo
    }

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Can we avoid this dependency ambiguity without using @Qualifier ?

- @Resource(name="classname in camelcase"): Dependency injection by name. Part of Java EE specification. Can be used for injecting resources and Spring-managed beans.
                                            Can be applied to fields, setter methods, and constructors.

- @Qualifier: Dependency injection by type and qualifier. Specific to Spring. Used to resolve ambiguity when multiple beans of the same type are present. Works with @Autowired or @Inject annotations.
              Provides more control over bean injection.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is bean scope & Can you explain different type of bean scope ? // singleton*, prototype*, request*, session*, webscoket(per websocket), application (entire webapp)

Bean scope is a life time/life cycle of a spring bean within the IOC container.
Singleton (Default): This is the default scope of spring bean. In the singleton scope, Spring Boot creates a single instance of the bean for the entire application context.
Prototype: A new bean instance is created every time a bean is requested.
Request: Only a single instance will be created and available during the complete lifecycle of an HTTP request. Only valid in the context of a web-aware Spring ApplicationContext.
Session: Only a single instance will be created and available during the complete lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext.
Application: Only a single instance will be created and available during the complete lifecycle of ServletContext. Only valid in the context of a web-aware Spring ApplicationContext.
Websocket: Only a single instance will be created and available during the complete lifecycle of WebSocket. Only valid in the context of a web-aware Spring ApplicationContext.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to define custom bean scope ?//scenario where i need to create bean for every thread then existing scope will not help. Implement scope interface override get and remove method

Implement Scope interface in your custom scope class override all the methods important methods are get() and remove(). Write logic of custom scope in to these to method.
After that we can use custom scope on any spring bean line @Scope("threadScope").
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Can you provide a few real-time use cases for when to choose Singleton scope and Prototype scope ?
//single: caching an instance, Thread safety db connection pool & db config, appn config like shared resourc across appn & prot: For database repository components that manage a
connection to a database and need a new instance per transaction or request. Example: JPA Repositories.

Singleton Scope:

1. Caching Service: If you have a service responsible for caching frequently accessed data, such as user sessions or configuration settings, using a Singleton scope ensures that
there's only one instance of the caching service throughout the application. This helps in efficient management of cached data and reduces memory overhead.

2. Thread Safety Management: For managing resources that require thread safety, such as database connection pools or configurations that are shared across multiple threads, Singleton
scope ensures that there's only one instance of the resource, preventing potential race conditions and ensuring thread safety.

3. Application Configuration: Singleton scope is suitable for managing application-wide configurations or resources that are shared across different parts of the application.
For example, a logging service or a configuration manager that provides access to application properties.

Prototype scope:

1. User Session Management: In web applications, each user session typically requires a unique session object to store user-specific data, such as shopping cart items, preferences,
or session state. Using Prototype scope for the session management component ensures that a new instance is created for each user session, allowing for independent session handling
and preventing data leakage between sessions.

2. Email Sending: In applications where emails need to be sent to multiple recipients with different content or configurations, components responsible for email composition and sending
may require unique instances for each email task. Using Prototype scope for these components ensures that a new instance is created for each email sending task, allowing for customization
 and preventing interference between different email sends.

In summary, Prototype scope is suitable for components that need to maintain state specific to each instance or require independent instantiation for each usage scenario, such as report
generation, email sending, data transformation, file processing, and image processing.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
can we inject prototype bean in singleton bean ? if yes what will happen if we inject prototype bean in singleton bean ?

Yes, we can inject a prototype-scoped bean into a singleton-scoped bean. However, when a prototype-scoped bean is injected into a singleton bean, the prototype bean will lose its own scope
and behave as if it were a singleton, inheriting the lifecycle of the singleton bean. This means that subsequent calls to the injected prototype bean within the singleton bean will
return the same instance.

To overcome this issue, instead of autowiring the prototype bean directly into the singleton bean, you can autowire the ApplicationContext and retrieve the prototype bean from there.
However, this approach is not recommended as it involves manual management of bean lifecycle.

Another approach to address this issue is by using the @Lookup annotation or ObjectFactory<PrototypeBean> to retrieve a new instance of the prototype bean every time it is needed within
the singleton bean. This ensures that each invocation of the method accessing the prototype bean results in a new instance being created, maintaining the desired prototype scope behavior.

In summary, while it is possible to inject a prototype-scoped bean into a singleton-scoped bean, special care must be taken to ensure that the prototype bean behaves as expected
and maintains its own scope. Using @Lookup, ObjectFactory, or carefully managing bean retrieval from the ApplicationContext are ways to achieve this.

Example:

import org.springframework.beans.factory.ObjectFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

@Component
@Scope("singleton")
class SingletonBean {

    // @Autowired
    // ProtoTypeBean prototypeBean; (this will act as a singleton)

    // Approach 1: Retrieve prototype bean from ApplicationContext
    @Autowired
    private ApplicationContext context;

    public ProtoTypeBean getPrototypeBeanFromContext() {
        return context.getBean(ProtoTypeBean.class); /// not recommended as we are manually managing its life cycle

    }

    // Approach 2: Use ObjectFactory to get a new instance of prototype bean
    @Autowired
    private ObjectFactory<ProtoTypeBean> prototypeBeanObjectFactory;

    public ProtoTypeBean getPrototypeBeanFromObjectFactory() {
        return prototypeBeanObjectFactory.getObject();
    }

    // Approach 3: Use @Lookup annotation
    @Lookup
    public ProtoTypeBean getPrototypeBeanByLookup() {
        return null; // This method will be overridden by Spring
    }

}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is the difference between spring singleton and plain singleton ?
Java singleton: Ensures that only one instance of a class exists per JVM instance, typically implemented within the class itself.
Spring singleton: Ensures that only one instance of a bean exists per Spring application context, managed by the Spring IoC container.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is the purpose of the BeanPostProcessor interface in Spring, and how can you use it to customize bean initialization and destruction?
 //  this is used for performing operation before and after bean intialization...implememtn BeanPostProcessor interface and override its two method
 // postprocessbeforeintialization & postprocessafterintialization. example while returing user brean if i want to validate password at the the of initialization itself
 // there we can use it

The `BeanPostProcessor` interface in Spring is used to customize the initialization and destruction of beans managed by the Spring IoC container.
It provides hooks that allow you to intervene in the bean instantiation process and perform custom logic before and after the initialization of beans.

Example :While returning user bean, if i want to validate password at the the of initialization itself there we can use BeanPostProcessor interface in such cases.

To use the `BeanPostProcessor` interface, you need to implement it and override its two methods: `postProcessBeforeInitialization` and `postProcessAfterInitialization`.

Here's an example of how you can implement the `BeanPostProcessor` interface to perform custom validation logic on a bean, such as validating a password during initialization:

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

@Component
public class PasswordValidationBeanPostProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object [bean], String beanName) throws BeansException {
        // Perform custom logic before bean initialization
        if (bean instanceof User) {
            User user = (User) bean;
            // Validate password before initialization
            if (!isValidPassword(user.getPassword())) {
                throw new IllegalArgumentException("Invalid password for user: " + user.getUsername());
            }
        }
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        // Perform custom logic after bean initialization
        return bean;
    }

    private boolean isValidPassword(String password) {
        // Implement password validation logic
        // For example, check password length, complexity, etc.
        return password != null && password.length() >= 8; // Example validation logic
    }
}

In this example, the `PasswordValidationBeanPostProcessor` class implements the `BeanPostProcessor` interface. It overrides the `postProcessBeforeInitialization` method to perform
password validation logic before the initialization of the bean. If the password is invalid, it throws an exception. You can also perform custom logic in the `postProcessAfterInitialization`
method if needed.

To use this `BeanPostProcessor`, you need to register it in your Spring configuration:

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {

    @Bean
    public PasswordValidationBeanPostProcessor passwordValidationBeanPostProcessor() {
        return new PasswordValidationBeanPostProcessor();
    }

    @Bean
    public User user() {
        User user = new UserO;
        user. setUsername("john");
        user.setPassword("t27t"); // exception occurs here at run time of application/ during application start
        return user;
    }
}

With this setup, whenever a bean of type `User` (or any other bean that requires password validation) is initialized within the Spring container,
the `PasswordValidationBeanPostProcessor` will intercept the initialization process and perform the password validation logic before allowing the bean to be initialized.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Have you worked on Restful webservices ? If yes What all HTTP methods have you used in your project ?
- GET (Fetch)
- PUT (Update)
- POST (Save/Create)
- PATCH (Partial Update)
- DELETE (Delete)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How can you specify the HTTP method type for your REST endpoint?

Note: @RequestMapping is the parent annotation for all annotations (@GetMapping, @PutMapping, @PostMapping etc etc)

@RestController
@RequestMapping("/usage")
public class ElectricityUsageController {

    @Autowired
    private ElectricityUsageService electricityUsageService;


    @GetMapping("/lastWeek/{smartMeterId}") //like this
    public ResponseEntity<LastWeekUsageResponse> getLastWeekUsage(@PathVariable String smartMeterId) {
        try {
            LastWeekUsageResponse lastWeekUsageResponse = electricityUsageService.getLastWeekUsage(smartMeterId);
            return ResponseEntity.status(HttpStatus.OK).body(lastWeekUsageResponse);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Scenario : Can you design a rest endpoint , Assume that you have a Product database, and your task is to create an API to filter a list of products by productType ?


Here's how you can design a REST endpoint in Spring Boot to filter a list of products by product type:

1. Define a `Product` entity representing your product in the database:


@Entity
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String productType;

    // Getters and setters
}

2. Create a `ProductRepository` interface extending `JpaRepository` to perform CRUD operations:


public interface ProductRepository extends JpaRepository<Product, Long> {

    List<Product> findByProductType(String productType);
}

3. Implement a `ProductService` to handle business logic:

@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;

    public List<Product> getProductsByType(String productType) {
        return productRepository.findByProductType(productType);
    }
}

4. Create a `ProductController` to define the REST endpoint:

@RestController
public class ProductController {

    @Autowired
    private ProductService productService;

    @GetMapping("/products")
    public List<Product> getProductsByType(@RequestParam("type") String productType) {
        return productService.getProductsByType(productType);
    }
}

5. Now, you can send a GET request to `/products?type={productType}` to filter products by their type.

Example request: GET /products?type=electronics
This will return a list of products with the product type "electronics".
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Scenario : Design endpoints in a way that takes “productType” as input. If the user provides this input, the endpoint should filter products based on the specified condition.
If “productType” is not provided, the endpoint should return all the products. ?

To design endpoints that handle filtering based on the "productType" input and return all products if the input is not provided, you can modify the `ProductController` as follows:



@RestController
public class ProductController {

    @Autowired
    private ProductService productService;

    @GetMapping("/products")
    public ResponseEntity<?> findProducts(@RequestParam(value = "productType", required = false) String productType) {
        List<Product> products;
        if (productType != null) {
            products = productService.getProductsByType(productType);
        } else {
            products = productService.getAllProducts();
        }
        return ResponseEntity.ok(products);
    }
}


In this modified controller, the `productType` parameter is annotated with `@RequestParam(required = false)`, which means it's optional. If the user provides the `productType`
parameter in the request, the controller will filter the products by that type using the `ProductService`. If the `productType` is not provided, it will call the `getAllProducts()`
method of `ProductService` to return all products.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is the difference between @PathVariable & @RequestParam ?

- `@PathVariable`: This annotation is used to extract values from the URI path of the request. It binds the placeholder in the URI template to a method parameter in the handler method.
                   It is typically used for mandatory parameters.

- `@RequestParam`: This annotation is used to extract values from the query string or form data of the request. It binds the request parameter to a method parameter in the handler method.
                   It is typically used for optional parameters, and it can have default values.

- `@PathVariable` extracts values from the URI path and is typically used for mandatory parameters.
- `@RequestParam` extracts values from the query string or form data and is typically used for optional parameters, with the option of providing default values.


@RestController
@RequestMapping("/products")
public class ProductController {

    @GetMapping("/category/{category}")
    public ResponseEntity<?> getProductsByCategory(@PathVariable("category") String category) {
        List<Product> products = productService.findByCategory(category);
        return ResponseEntity.ok(products);
    }

    @GetMapping("/search")
    public ResponseEntity<?> searchProductsByType(@RequestParam(value = "type", required = false) String type) {
        if (type != null) {
            // Pseudo code to fetch products by type from the database
            List<Product> products = productService.findByType(type);
            return ResponseEntity.ok(products);
        } else {
            // If type is not provided, return all products
            List<Product> allProducts = productService.getAllProducts();
            return ResponseEntity.ok(allProducts);
        }
    }

    @GetMapping("/default")
    public ResponseEntity<?> getProductsByDefaultType(@RequestParam(value = "type", defaultValue = "electronics") String type) {
        // Pseudo code to fetch products by the default type from the database
        List<Product> products = productService.findByType(type);
        return ResponseEntity.ok(products);
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Why did you use @RestController why not @Controller ?

The `@RestController` annotation in Spring is a specialized version of the `@Controller` annotation that is typically used for RESTful web services.
It combines the functionality of both `@Controller` and `@ResponseBody`.

Here's the difference:

- @Controller: This annotation is used to mark a class as a controller in Spring MVC. It is typically used to create web applications that return views (HTML pages) to the client.

- @RestController: This annotation is a convenience annotation that combines `@Controller` and `@ResponseBody`. It is used to create RESTful web services that return data
  (such as JSON, XML, etc.) directly to the client, rather than rendering a view.

In the scenario of designing REST endpoints to return JSON or XML data (like in our example of fetching products), it's more appropriate to use `@RestController`
because it automatically serializes the return value of the controller methods into the response body. This eliminates the need for an explicit `@ResponseBody` annotation on each method.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How can we deserialize a JSON request payload into an object within a Spring MVC controller ?

We can use the `@RequestBody` annotation to deserialize a JSON request payload into an object within a controller method. Here's how you can use it:


@RestController
public class MyController {

    @PostMapping("/api/endpoint")
    public ResponseEntity<?> handleRequest(@RequestBody MyRequestObject requestObject) {
        // Here, requestObject will contain the deserialized JSON payload
        // You can now process the requestObject and return a response
        return ResponseEntity.ok("Request received successfully");
    }
}

In this example, `MyRequestObject` is a POJO (Plain Old Java Object) representing the structure of the JSON payload. When a POST request is sent to the `/api/endpoint`
endpoint with a JSON payload in the request body, Spring automatically deserializes the JSON into an instance of `MyRequestObject` and passes it as an argument
to the `handleRequest` method.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Can we perform update operation in POST http method if yes then why do we need Put Mapping or put http method? //


### Using POST Method for Update (Not recommended way) (POST is not idempotent)

@RestController
@RequestMapping("/users")
public class UserController {

    @PostMapping("/{userId}")
    public ResponseEntity<User> updateUserProfile(@PathVariable String userId, @RequestBody UserProfileRequest request) {
        User updatedUser = userService.updateUserProfile(userId, request);
        return ResponseEntity.ok(updatedUser);
    }
}

#### Server Behavior:
- With the POST method, each request to update the user profile will create a new resource or modify an existing one if specified.
- The server may treat each request as independent, potentially leading to duplicate resources or unintended changes.

#### Database Updates:
- In the database, each POST request to update the user profile may result in the creation of a new record or modification of an existing one, depending on how the service is implemented.
- There's no guarantee of idempotency, meaning multiple identical requests may lead to different outcomes.

### Using PUT Method for Update

@RestController
@RequestMapping("/users")
public class UserController {

    @PutMapping("/{userId}")
    public ResponseEntity<User> updateUserProfile(@PathVariable String userId, @RequestBody UserProfileRequest request) {
        // Code to update user profile using PUT method
        User updatedUser = userService.updateUserProfile(userId, request);
        return ResponseEntity.ok(updatedUser);
    }
}

#### Server Behavior:
- With the PUT method, each request to update the user profile will replace the existing resource or create a new one if it doesn't exist.
- The server treats each PUT request as idempotent, ensuring that multiple identical requests have the same effect as a single request.

#### Database Updates:
- In the database, each PUT request to update the user profile typically replaces the existing record with the new data provided.
- The operation is idempotent, meaning multiple identical PUT requests will result in the same state in the database.

### Idempotency:

- Idempotency means that making the same request multiple times should have the same effect as making it once.
- PUT requests are inherently idempotent because they replace the resource's state with the provided data, ensuring that repeating the request won't change the outcome.
- POST requests, on the other hand, are not idempotent by default because they typically create new resources or modify existing ones without guaranteeing the same outcome
for identical requests.

#### Real-Life Example:

Consider a user management API where clients interact with user resources. When a user wants to update their profile information, using the PUT method ensures that each request
replaces the existing user profile with the new data, maintaining consistency and predictability in the system. This is crucial for scenarios where data integrity and reliability
are paramount, such as updating financial records or medical information.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Can we pass Request Body in GET HTTP Method ?
Yes, but no recommended as per REST principle.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How can we perform content negotiation (XML/JSON) in Rest endpoint ?

Let's consider a practical example of content negotiation in a Spring Boot RESTful API for a simple bookstore.

Suppose we have a `Book` entity with attributes like `id`, `title`, `author`, and `isbn`. We want our API to support both JSON and XML representations
of `Book` objects based on client preferences.

Here's how you can implement content negotiation in such an API:

Add dependency in pom.xml:

<dependency>
    <groupId>com.fasterxml.jackson.dataformat</groupId>
    <artifactId>jackson-dataformat-xml</artifactId>
</dependency>


1. Define the Book entity:

public class Book {
    private Long id;
    private String title;
    private String author;
    private String isbn;

    // Getters and setters
}


2. Create a REST controller:

import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.Arrays;
import java.util.List;

@RestController
@RequestMapping("/books")
public class BookController {

    @GetMapping(produces = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
    public List<Book> getAllBooks() {
        // Assume books are fetched from a service or repository
        return Arrays.asList(
            new Book(1L, "Java Programming", "John Doe", "1234567890"),
            new Book(2L, "Spring Boot in Action", "Jane Smith", "0987654321")
        );
    }
}

In this controller, we use the `@GetMapping` annotation with the `produces` attribute to specify that this endpoint can produce both JSON and XML responses.

3. Configure content negotiation in application properties:

properties
# application.properties
spring.mvc.contentnegotiation.favor-path-extension=false
spring.mvc.contentnegotiation.favor-parameter=true
spring.mvc.contentnegotiation.defaultContentType=application/json
spring.mvc.converters.preferred-json-mapper=jackson
spring.jackson.serialization.indent_output=true


Here, we configure Spring Boot to prefer content negotiation based on the request parameter (`favor-parameter=true`) and set the default content type to JSON
(`defaultContentType=application/json`).

4. Testing the API:
Now, clients can request books in either JSON or XML format by specifying the `Accept` header in their requests. For example:

- To get JSON representation: `curl -H "Accept: application/json" http://localhost:8080/books`
- To get XML representation: `curl -H "Accept: application/xml" http://localhost:8080/books`

By using content negotiation, our API can seamlessly support multiple formats, allowing clients to choose the representation that best suits their needs.
This enhances interoperability and flexibility in consuming the API.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What all status code you have observed in your application ?

- 400: Bad Request (The server cannot process the request due to a client error)
- 404: Not Found (The requested resource could not be found on the server)
- 401: Unauthorized (The request lacks valid authentication credentials for the target resource)
- 403: Forbidden (The server understood the request, but refuses to authorize it)
- 405: Method Not Allowed (The method specified in the request is not allowed for the resource identified by the request URI)
- 415: Unsupported Media Type (The server refuses to accept the request because the payload format is in an unsupported format)
- 500: Internal Server Error (A generic error message indicating that something went wrong on the server)
- 502: Bad Gateway (The server received an invalid response from an upstream server while acting as a gateway or proxy)
- 200: OK (The request was successful)
- 201: Created (The request has been fulfilled, resulting in the creation of a new resource)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How can you customize the status code for your endpoint ?

To customize the status code for your endpoint in Spring, you can use the `@ResponseStatus` annotation.
This annotation allows you to specify the HTTP status code that should be returned when the method is invoked.

Here's how you can use it:

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class MyController {

    @GetMapping("/example")
    @ResponseStatus(HttpStatus.ACCEPTED) // Customize the status code
    public String exampleEndpoint() {
        return "Custom status code example";
    }
}

In this example, the `exampleEndpoint()` method is annotated with `@ResponseStatus(HttpStatus.ACCEPTED)`, which sets the HTTP status code to 202 (Accepted) for
the `/api/example` endpoint. You can replace `HttpStatus.ACCEPTED` with any other HTTP status code that suits your requirements.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How can you enable cross origin ?


Cross-origin resource sharing (CORS) is a browser security feature that stops websites from making requests to different websites, which helps prevent certain types of cyber attacks.
Enabling CORS is necessary when you're building a web application that needs to talk to other websites. For example, if your website wants to fetch data from another website's API,
you need to enable CORS to make that work.

In Spring Boot , you can enable CORS by using the `@CrossOrigin` annotation. Here's how it works:

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class MyController {

    @GetMapping("/example")
    @CrossOrigin(origins = "http://example.com")
    public String exampleEndpoint() {
        return "Response from example endpoint";
    }
}

In this example:
- We have a controller method (`exampleEndpoint()`) that handles requests to `/api/example`.
- We add `@CrossOrigin(origins = "http://example.com")` to allow requests from `http://example.com` to access this endpoint.

You can also set up CORS globally for your entire Spring Boot application by creating a configuration class like this:

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.*;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/")
                .allowedOrigins("http://example.com") // for all @CrossOrigin("*")
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                •allowedHeaders("Origin", "Content-Type", "Accept", "Authorization")
                .allowCredentials(true);
    }
}

In this configuration:
- `addCorsMappings()` method enables CORS for all endpoints (`"/"`) in your app.
- It allows requests from `http://example.com`.
- You can specify other origins and HTTP methods as needed.

To allow all type of request to your controller you can add @CrossOrigin("*") at controller itself.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How can you upload a file in spring ?

In Spring Boot, you can upload files using the `multipart/form-data` content type (MultipartFile). Here's a basic example of how to do it:

1. Controller Endpoint: Create a controller endpoint to handle the file upload.

import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import java.io.IOException;

@RestController
@RequestMapping("/api")
public class FileUploadController {

    @PostMapping("/upload")
    public String uploadFile(@RequestParam("file") MultipartFile file) throws IOException {
        // Process the uploaded file
        byte[] bytes = file.getBytes();
        // Save the file or perform any other operation
        // For simplicity, we'll just return the file name
        return "File " + file.getOriginalFilename() + " uploaded successfully";
    }
}


2. Spring Boot Configuration: Ensure that your Spring Boot application is configured to handle multipart requests.
 This is usually done automatically, but you can customize it if needed.


import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.MultipartConfigFactory;
import org.springframework.context.annotation.Bean;
import javax.servlet.MultipartConfigElement;

@SpringBootApplication
public class FileUploadApplication {

    public static void main(String[] args) {
        SpringApplication.run(FileUploadApplication.class, args);
    }

    @Bean
    public MultipartConfigElement multipartConfigElement() {
        MultipartConfigFactory factory = new MultipartConfigFactory();
        // Set the maximum file size allowed (optional)
        factory.setMaxFileSize("10MB");
        // Set the maximum request size allowed (optional)
        factory.setMaxRequestSize("10MB");
        return factory.createMultipartConfig();
    }
}


With these components in place, your Spring Boot application should be able to handle file uploads. When a file is uploaded via the form, it will be sent to the `/api/upload` endpoint,
where you can process it as needed.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How do you maintain versioning for your REST API?


When you're building a web service with Spring Boot, you might want to update or add new features to it over time. But what happens if you need to make changes to
your existing API without breaking the apps that are already using it? That's where versioning comes in.

Versioning is a way to manage changes to your API while ensuring that existing users can still access the old version if they need to.

Here are two common ways to version your API:

1. URI Versioning: You include the version number directly in the URL of your API endpoints.
For example, you might have `/api/v1/endpoint` for version 1 and `/api/v2/endpoint` for version 2.

@RestController
@RequestMapping("/api/v1")
public class MyController {
    // API endpoints
}

We can apply same thing as above at method level as well

2. Request Parameter or Header Versioning: Instead of putting the version number in the URL, you include it as a parameter or header in the request.
For example, you could have a parameter like `?version=1` or a header like `X-API-Version: 1`.

@RestController
   @RequestMapping("/api")
   public class MyController {

       @GetMapping(value = "/endpoint", params = "version=1")
       public String getEndpointV1() {
           // Logic for version 1
       }

       @GetMapping(value = "/endpoint", params = "version=2")
       public String getEndpointV2() {
           // Logic for version 2
       }
   }

or

 @RestController
   @RequestMapping("/api")
   public class MyController {

       @GetMapping(value = "/endpoint", headers = "X-API-Version=1")
       public String getEndpointV1() {
           // Logic for version 1
       }

       @GetMapping(value = "/endpoint", headers = "X-API-Version=2")
       public String getEndpointV2() {
           // Logic for version 2
       }
   }

Both methods have their pros and cons, so you'll need to choose the one that works best for your project.
But the main idea is to make sure that your API changes don't cause problems for the apps that rely on it.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How will you document your rest API ?
Swagger, OPEN API
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How can you hide certain REST endpoints to prevent them from being exposed externally in swagger document?
@Hidden
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How will you consume restful API ?
- RestTemplate: RestTemplate is a synchronous HTTP client for making RESTful API calls in Spring Boot. It allows you to send HTTP requests and receive responses synchronously.

    // Using RestTemplate to fetch weather data
    RestTemplate restTemplate = new RestTemplate();
    String weatherData = restTemplate.getForObject("http://weather-api.com/data", String.class);
    System.out.println("Weather data: " + weatherData);

- FeignClient:  Feign is a declarative HTTP client developed by Netflix, and FeignClient is a Spring Boot annotation that allows you to create RESTful clients with ease.
                FeignClient simplifies the process of making HTTP requests by generating proxy implementations of your interfaces. It allows you to write cleaner and more
                concise code by abstracting away the details of HTTP communication. For example, if your microservice needs to call another microservice's API, you can use
                FeignClient to define an interface with the API endpoints and let Spring Boot handle the rest.

    // Using FeignClient to fetch weather data
    @FeignClient(name = "weather-service")
    public interface WeatherClient {
        @GetMapping("/data")
        String getWeatherData();
    }

    // In your service
    @Autowired
    private WeatherClient weatherClient;

    public void fetchWeatherData() {
        String weatherData = weatherClient.getWeatherData();
        System.out.println("Weather data: " + weatherData);
    }

- WebClient: Now, let's say you're building a real-time sports score app, and you want to show live updates. WebClient is like having a team of people constantly checking
             for updates and bringing them to you as soon as they're available. It's fast and efficient because it doesn't wait around for one request to finish before moving
             on to the next one.

             WebClient is a non-blocking, reactive HTTP client introduced in Spring WebFlux. It provides a more functional and asynchronous way of making HTTP requests compared
             to RestTemplate. WebClient is ideal for building reactive applications that require high concurrency and scalability.

       // Using WebClient to fetch sports scores
       WebClient webClient = WebClient.create("http://sports-api.com");
       Mono<String> scoreMono = webClient.get()
               .uri("/live-scores")
               .retrieve()
               .bodyToMono(String.class);

       scoreMono.subscribe(score -> System.out.println("Live score: " + score));

- Advance Rest Client: from spring 3.2
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How will you handle exceptions in your project ?

`@RestControllerAdvice` in Spring Boot allows you to globally handle exceptions thrown by your RESTful endpoints.


1. Create Custom Exception Class:

   public class CustomException extends RuntimeException {
       public CustomException(String message) {
           super(message);
       }
   }

2. Create Exception Handler:

   @RestControllerAdvice
   public class GlobalExceptionHandler {

       @ExceptionHandler(CustomException.class)
       @ResponseStatus(HttpStatus.BAD_REQUEST)
       public ErrorResponse handleCustomException(CustomException ex) {
           return new ErrorResponse("Custom exception occurred: " + ex.getMessage());
       }

       // Other exception handlers can be added here
   }


3. Create ErrorResponse Class:

   public class ErrorResponse {
       private String message;

       public ErrorResponse(String message) {
           this.message = message;
       }

       public String getMessage() {
           return message;
       }

       public void setMessage(String message) {
           this.message = message;
       }
   }


4. Usage in Controller:

   @RestController
   public class MyController {

       @GetMapping("/hello")
       public String sayHello() {
           // Simulate throwing custom exception
           throw new CustomException("Something went wrong!");
       }
   }


With this setup, whenever a `CustomException` is thrown from any controller method, it will be intercepted by the `GlobalExceptionHandler`, which will then return an error
response with a status code of 400 (Bad Request).

This setup ensures that your application gracefully handles exceptions and returns appropriate error responses to the client.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How can you avoid defining handlers for multiple exceptions, or what is the best practice for handling exceptions ?
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How will you validate or sanitise your input payload ? How can you populate validation error message to the end users


To validate or sanitize input payload in a Spring Boot application using Jakarta Bean Validation (`@Valid`), you can follow these steps:

1. Add Jakarta Bean Validation Dependency:
   Make sure you have the necessary dependencies in your `pom.xml` or `build.gradle` file to enable Jakarta Bean Validation.

2. Annotate Your DTO or Entity Class with Validation Annotations:
   Add validation annotations from the `javax.validation.constraints` package to your DTO or entity class fields to specify validation rules.

   public class UserDTO {

       @NotBlank(message = "Username is required")
       private String username;

       @Email(message = "Invalid email format")
       private String email;

       // Other fields and methods
   }

3. Use `@Valid` Annotation in Controller Method:
   Annotate your controller method parameter with `@Valid` to trigger validation.

   @RestController
   public class UserController {

       @PostMapping("/users")
       public ResponseEntity<String> createUser(@Valid @RequestBody UserDTO userDTO) {
           // Handle valid user DTO
           return ResponseEntity.ok("User created successfully");
       }
   }

4. Handle Validation Errors:
   If validation fails, Spring Boot will automatically throw a `MethodArgumentNotValidException`. You can handle this exception using `@ExceptionHandler` in a
   global exception handler or within the controller itself.

   @RestControllerAdvice
   public class GlobalExceptionHandler {

       @ExceptionHandler(MethodArgumentNotValidException.class)
       @ResponseStatus(HttpStatus.BAD_REQUEST)
       public ErrorResponse handleValidationExceptions(MethodArgumentNotValidException ex) {
           BindingResult result = ex.getBindingResult();
           List<String> errorMessages = result.getAllErrors().stream()
                                        .map(DefaultMessageSourceResolvable::getDefaultMessage)
                                        .collect(Collectors.toList());
           return new ErrorResponse("Validation error: " + errorMessages);
       }
   }

With this setup, when a request is made to the `/users` endpoint with an invalid user payload, Spring Boot will automatically validate the input against
the defined validation annotations. If validation fails, a `MethodArgumentNotValidException` will be thrown, and the global exception handler (`GlobalExceptionHandler`)
will catch the exception and return an appropriate error response.

This approach helps ensure that only valid input data is accepted by your API endpoints, improving the overall reliability and security of your application.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
use case : let’s say you find a bug in production environment and now you want to debug that scenario ,How can you do that from your local ?
spring.profiles.active = dev in application.prop file
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Here are the explanations of the listed Maven commands:

- `mvn compile`: Compiles the Java classes (.java files) in the project and generates the corresponding .class files in the `/target/classes` directory.

- `mvn test-compile`: Compiles the Java test class files in the project and generates the corresponding .class files in the `/target/test-classes` directory.

- `mvn clean`: Deletes the `/target` directory, removing any compiled classes, generated files, and artifacts.

- `mvn test`: Executes JUnit test files present in the project.

- `mvn validate`: Validates the project's `pom.xml` file, ensuring it is syntactically correct, adheres to the XML structure, and contains the required dependencies and plugins.
                  Additionally, it verifies that the project directory structure complies with Maven's standard layout and validates any custom configurations specified in Maven
                  plugins or build profiles.

- `mvn install`: Validates the `pom.xml` file, compiles the source code, executes JUnit tests, and packages the application as a JAR or WAR file. The resulting artifact is then
                 installed in the local Maven repository, making it available for use as a dependency in other projects.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Maven life cycle: The Maven lifecycle refers to the sequence of build phases that are executed by Maven when any Maven command is run.
These phases includes various tasks such as compiling source code, running tests, packaging artifacts, and deploying the project. Each phase represents
a specific stage in the build process, and Maven plugins can bind to these phases to execute custom actions.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 `mvn deploy` command and its use in real life, presented in bullet points:

- `mvn deploy` is a Maven command used to deploy built artifacts (such as JAR or WAR files) to a remote repository.
- It is typically used in scenarios where you want to share your project's artifacts with other developers or teams, or when you want to deploy your project to a
central repository for use in other projects.
- When executed, `mvn deploy` uploads the built artifact to a remote repository, such as Nexus, Artifactory, or a custom repository manager.
- This command is commonly used in continuous integration (CI) and continuous deployment (CD) pipelines to automate the deployment process.
- It ensures that the latest version of your project's artifact is available for consumption by other projects or developers.
- By deploying artifacts to a remote repository, `mvn deploy` facilitates collaboration and promotes reusability across different projects within an organization.
- `mvn deploy` can also be integrated with version control systems and build servers to automate the deployment process whenever a new version of the project is built or released.
- In real-life scenarios, `mvn deploy` is often used in conjunction with other Maven commands, such as `mvn clean install`, to build, test, package, and deploy artifacts in
 a streamlined and automated manner.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
The `mvn dependency:tree` command in Maven generates a visual representation of the project's dependencies and their transitive dependencies. It helps developers understand, manage,
 and troubleshoot dependency-related issues by providing a hierarchical tree structure of the project's dependencies.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How can you define custom bean validation ?

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How can you enable a specific environment without using profiles? OR what is the alternative to profiles to achieving same use case ?

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is the difference between @Profile & @ConditioOnXXX ?
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is AOP ?
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is pointcut & join Points in AOP ?
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What are different type of advice ?
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
use case — can I use AOP to evaluate performance of a method or is this possible to design a logging framework to capture request and response body of a method ?
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------