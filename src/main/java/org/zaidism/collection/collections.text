Internal working of HashMap: HashMapExample.java

Note: Average case complexity of Insert, Update, Delete in hashmap take O(1) and worst case due to collisions leading to long linked lists, degrade to O(n)
      Hash map try to convert all of the data of your entries into compressed form using hashcode by applying hashing algorithm.


How put method works in hashmap?

When you create a HashMap shown as below

HashMap<String, Integer> map = new HashMap<>();
map.put("Jahid", 1);

- Once you put element in Hashmap initially 16 buckets gets formed (0-15) in hash table, once you reach the threshold index value which is more than 12 in hashmap, bucket size increases.
  Buckets increases based on some formula to resize map in debug it just doubled the size from 16 to 32.

- Every index is this bucket act as of linked lists/nodes which has this kind of structure [Hashcode|Key|Value|Next]

- Once put method of hashmap is called hash function gets called on key object it will give the hashcode, On the basis of that hashcode, index for this first entry gets calculated
  using index in bucket determined by using this function/formula hashCode&(n-1).

- Let's assume it has return index 4 so at index in the bucket one node gets created with value like this [12342|Jahid|1|null]

- If i add 2nd entry to the map as map.put("Amina", 2); [12342|Amina|2|null] and if hash function calculates the same hashcode on the key then the index would be again 4 for this
  hash map entry as well this situation is called as hash collision.

- In hash collision situation, equals function gets applied on both the keys to check if they are not equal then in the existing entry will have Next address for the 2nd entry in hashmap
  [12342|Jahid|1|1213x]-------------->[12342|Amina|2|null] at index 4th of bucket.

- On equals function application if both the keys are equal then in the existing entry will be replaced by new entry in the map

- If multiple linked list gets formed within the same index then JVM has to traverse through the linked list which is not in O(1) so in java 8 to address this issue hashmap replaces
  linked list with a balanced tree (red-black tree) to improve performance when a number of element in the bucket reached to certain threshold.

- If you provide null keys on hashmap then that entry in the form of node always gets stored at 0th index in the bucket pf hashtable. HashMaps allow one null key.

- While keys can have a null value, values in a HashMap can also be null

- When we put same key in the hashmap it will replace the existing entry in the hash map with the latest one


How get method works in hashmap?

- When you use `hashMap.get("Amina")`, the hash function calculates the hashcode for the key "Amina."
- Using the hashcode, an index is determined within the HashMap's internal array of buckets. This index is calculated as `index = hashCode & (n-1)`.
- In the bucket at the calculated index, the HashMap checks if there are one or more entries (nodes) with matching hashcodes.
- If a matching hashcode is found, the `equals` method is used to check which node's key matches the provided key ("Amina").
- If a matching key is found within a node, the `get` method returns the corresponding value associated with that key.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
• A iterator which will fail fast when we do any modification while iterating a collection is called fail fast iterator
  Ex : (ArrayList ,HashMap and Vector)
• Iterator who allow us to modify in middle while iterating a collection is called Non-Fail Fast (Fail Safe) Iterator
  Ex: (CopyOnWriteArrayList, CopyOnWriteArraySet, ConcurrentHashMap)

FailFastFailSafeExample.java

Fail-Safe:
- Fail-safe iterators operate on a copy of the collection instead of the original collection.
- Changes made to the original collection during iteration do not affect the iterator.
- Fail-safe iterators do not throw `ConcurrentModificationException`.
- Instead of relying on mod counts, fail-safe iterators often use mechanisms such as snapshotting (creating a copy of the collection when iteration begins) or
  maintaining a separate data structure for tracking modifications, ensuring that the iterator can continue iterating over the original collection without interference
  from concurrent modifications.

Fail-Fast:
- Fail-fast iterators operate directly on the original collection.
- If the collection is modified structurally while iterating (adding, removing), `ConcurrentModificationException` is thrown.
- During iteration, the iterator checks this modification count. If it detects that the count has changed since the iteration began, it indicates that the collection
  has been modified concurrently, and it throws a ConcurrentModificationException.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Refer: ConcurrentHashMapvsHashTable.jpg

              ConcurrentHashMap                            Hashtable
 _________________________________________    _________________________________________
|                                         |  |                                         |
|  Multiple Segments for Concurrency     |  |  Single Global Lock for Synchronization |
|  (Divides Map into Segments, Each       |  |                                         |
|  with Independent Lock)                 |  |                                         |
|                                         |  |                                         |
|        Segment 1      Segment 2         |  |                                         |
|         |  |  |         |  |  |          |  |                                         |
|        Entry 1       Entry 2            |  |                Entry                   |
|         |             |                |  |                 |                     |
|       Entry 3       Entry 4             |  |                Entry                   |
|_________________________________________|  |_________________________________________|

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
We Can Synchronize a HashMap using Collections then why can't we use that instead using ConcurrentHashMap ?
Ans : if we used Collections.synchronizedMap(map) it will act as a synchronized Hashtable only where again locking mechanism is different
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Why Set doesn't allow duplicate values?

- In Java, for example, the HashSet implementation of the Set interface uses a HashMap internally to store its elements. When you add an element to a HashSet,
  it is added as a key in the HashMap, with a dummy value. The uniqueness of keys in a HashMap is enforced by the hashing and equality comparison mechanisms.

- Set can contains duplicate elements for custom objects if hashCode and equals methods are not override as per their contract.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Can I add element in final ArrayList?

refer: FinalArrayList.java

- Yes but we can't re-assign it as show below it will give completion error
      final List<Integer> nums= new ArrayList<>();
        nums = new ArrayList<>();
- To achieve immutability in array list we can use Collections.unmodifiableList method
       // Creating a regular ArrayList
        List<String> mutableList = new ArrayList<>();
        mutableList.add("apple");
        mutableList.add("banana");
        mutableList.add("orange");

        // Creating an immutable view of the ArrayList
        List<String> immutableList = Collections.unmodifiableList(mutableList);
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ArrayList for storing and accessing data as it works on indexed based search like array so these operation are faster.
LinkedList is better suitable for manipulating data.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
HashMap vs ConcurrentHashMap

HashMap: not thread safe, fail fast, allow storing null keys and values, faster than ConcurrentHashMap
ConcurrentHashMap: thread safe, fail safe, doesn't allow storing null keys and values, slower than HashMap
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
We Can Synchronize a HashMap using Collections then why can't we use
that instead using ConcurrentHashMap?
Ans : if we used Collections.synchronizedMap(map) it will act as a synchronized Hashtable only where again locking mechanism is different
Refer: ConcurrentHashMapvsHashTable.jpg