Spring boot interview questions (Source: https://medium.com/@javatechie/spring-boot-in-depth-interview-faqs-62edf6cda4e7)
https://www.youtube.com/playlist?list=PLVz2XdJiJQxwS8FyWnWyKyfILxHPLsiro
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What all spring boot starter you have used or what all module you have worked on ?

 - spring-boot-starter-web
 - spring-boot-starter-data-jpa
 - spring-boot-starter-security
 - spring-boot-starter-cache
 - spring-boot-starter-cloud
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How will you run your Spring Boot application ?

    1. mvn spring-boot:run
    2. mvn clean install
       java -jar target/your-application.jar
    3. Run the main class with @SpringBootApplication.

 - When we run spring boot application it, spring does not implicitly creates jar file for your project instead it runs .class file for your main spring class annotated
   with @SpringBootApplication.
 - When we do mvn clean install it actually generates the jar file inside the target folder
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is the purpose of the @SpringBootApplication annotation in a Spring Boot application ?

- Combines Annotations:
  - Meta-annotation that combines `@Configuration`, `@EnableAutoConfiguration`, and `@ComponentScan`.

- Configuration:
  - Indicates the class is a configuration class.
  - Allows definition of beans and configuration settings.
  - On application start up loads all the configuration classes

- Auto-Configuration:
  - Enables Spring Boot's automatic configuration.
  - Configures the application based on dependencies and classpath.

- Component Scanning:
  - Activates component scanning for Spring components (`@Component`, `@Service`, `@Repository`, etc.).
  - Automatically discovers and registers Spring beans.
  - It scan current class and it's subpackages to discovers and registers Spring beans.

- Main Application Class:
  - Typically used on the class containing the `main` method.
  - Serves as the entry point, bootstrapping the Spring Boot application.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
can I directly use @EnableAutoConfiguration, @ComponentScan & @Configuration annotation in my main class , instead of using @SpringBootApplication annotation,
 if yes will my application work as expected ?

 - Yes we can use directly these annotation instead of @SpringBootApplication. There will be no impact. Below are the examples of it

 @Configuration
 @EnableAutoConfiguration
 @ComponentScan
 @Import({MyAdditionalConfiguration.class, AnotherConfiguration.class})
 public class MySpringBootApp {

     public static void main(String[] args) {
         // Your application logic here
     }
 }

  @Configuration
  @EnableAutoConfiguration
  @ComponentScan
  public class MySpringBootApp {

      public static void main(String[] args) {
          // Your application logic here
      }
  }

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Auto configuration in spring boot ?

Auto-Configuration in Spring Boot:

- Automated Configuration:
  - Spring Boot's auto-configuration automatically configures the application based on its dependencies and the classpath.
  - Reducing the need for explicit configuration.

- Default Settings:
  - Provides sensible default settings for various components, reducing the burden on developers to configure them manually.

- Annotation: `@EnableAutoConfiguration`:
  - Applied at the class level to enable auto-configuration.
  - Typically included in the `@SpringBootApplication` annotation.

- Example 1 - DataSource Configuration:
  - If `spring-boot-starter-data-jpa` is in the classpath, Spring Boot auto-configures a `DataSource` bean.
  - No need for explicit configuration unless custom settings are required.

  // Main class with @SpringBootApplication
  @SpringBootApplication
  public class MySpringBootApp {

      public static void main(String[] args) {
          // Your application logic here
      }
  }

  // No explicit DataSource configuration required
  @Entity
  public class MyEntity {
      // Entity definition
  }

- Example 2- Web Server Configuration:

  If spring-boot-starter-web is in the classpath, Spring Boot auto-configures an embedded web server (e.g., Tomcat, Jetty).
  Developers don't need explicit configuration for basic web server setup.

- Customization:
  - Developers can override auto-configured settings or provide custom configurations when needed.

- Simplifies Development:
  - Developers can focus on application-specific configurations rather than boilerplate setup.

In summary, Spring Boot's auto-configuration simplifies development by providing sensible defaults and automatically configuring components based on the project's
dependencies and classpath. It follows the convention over configuration principle, reducing the need for explicit configuration.


- Understand which classes and configurations are auto-configured by Spring Boot when adding the `spring-boot-starter-web` dependency or any other dependencies.

 Steps:
   - Add the `spring-boot-starter-web` dependency to the project.
   - Enable debug mode in the `application.properties` file by adding `debug=true`.

 Execution:
   - Start the application.
   - During startup, Spring Boot evaluates conditions and identifies positive and negative matches for auto-configuration.

 Analysis:
   - Check the logs for positive matches (configurations enabled by default) and negative matches (configurations not enabled).
   - Example: Jackson Auto Configuration is mentioned as a positive match, indicating that it will be auto-configured for the application.

 Outcome:
   - Understand which configurations Spring Boot automatically enables based on the project's dependencies and classpath.

Keep in mind that the actual details of positive and negative matches will be visible in the debug logs during application startup.
The example highlights the Jackson Auto Configuration as one of the positive matches.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How can you disable a specific auto-configuration class in Spring Boot ?

 - To disable a specific auto-configuration class using annotations, you can use the `@SpringBootApplication` annotation along with `exclude` attribute. Here's how you can do it:

        @SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
        public class MySpringBootApp {

            public static void main(String[] args) {
                SpringApplication.run(MySpringBootApp.class, args);
            }
        }
 - In this example, the `@SpringBootApplication` annotation includes the `exclude` attribute, where you specify the auto-configuration class you want
   to exclude (`DataSourceAutoConfiguration` in this case). This approach allows you to disable specific auto-configurations directly in your main application class.

        or

   - Using `application.properties`:

   - spring.autoconfigure.exclude=org.example.ExcludedAutoConfiguration

   - Replace `org.example.ExcludedAutoConfiguration` with the fully qualified name of the auto-configuration class you want to exclude.

   - For example, if you want to disable the `DataSourceAutoConfiguration` class, which is responsible for configuring a `DataSource` based on the classpath, you can do the following:

   - spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration

   - This disables the auto-configuration specifically for `DataSourceAutoConfiguration`.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How can you customize the default configuration in Spring Boot like port no?


 In Spring Boot, you can customize default configurations, such as the server port, by using properties. These properties can be defined in the application.properties
 or application.yml file or overridden programmatically in your Spring Boot application. Here's how you can customize the default server port:

 Using application.properties or application.yml:

 Add the following property to your application.properties or application.yml file:

 server.port=your-desired-port
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How Spring boot run() method works internally ?

 - Creates ApplicationContext
 - Register Bean into Context
 - Start up embedded tomcat container to run the jar/war

Here's a concise breakdown of how the `run()` method works internally in Spring Boot:

- ApplicationContext Creation:
  - The `run()` method initializes and creates the ApplicationContext.
  - Before creating ApplicationContext inside run method it loads environment based the configuration provided in prop or yaml file
  - ApplicationContext is a container that holds and manages beans (objects) for the application.
  - While creating ApplicationContext it checks application type as well whether it is a WebApplication or some other type of application in spring

- Bean Registration:
  - Beans (components of the application) are registered with the ApplicationContext through component scan.
  - These can be user-defined beans or Spring Boot's auto-configured beans.

- Starting Embedded Tomcat Container:
  - If the application is a web application, Spring Boot starts an embedded Tomcat container.
  - This container is responsible for handling HTTP requests and serving the application.

- Application Execution:
  - The application logic, including user-defined `@SpringBootApplication` annotated classes, is executed.
  - This is where the core functionality of the application is implemented.

- Graceful Shutdown Setup:
  - A shutdown hook is set up to ensure a graceful shutdown when the application is terminated.

In summary, the `run()` method in Spring Boot performs the essential steps of setting up the ApplicationContext, registering beans, starting an embedded Tomcat container
(if it's a web application), executing the application logic, and preparing for a graceful shutdown.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Command line runner in spring boot ?

    - In Spring Boot, a CommandLineRunner is an interface that provides a way to execute code after the Spring Boot application has started.
      It is a part of the Spring Boot application lifecycle and allows developers to run custom logic or tasks that need to be executed once
      the application context has been fully initialized.

    - To use CommandLineRunner, you implement the interface in a Spring Bean or component.
    - The run method contains the custom logic that you want to execute after the application starts.
    - CommandLineRunner is a functional interface

    import org.springframework.boot.CommandLineRunner;
    import org.springframework.stereotype.Component;

    @Component
    public class MyCommandLineRunner implements CommandLineRunner {

        @Override
        public void run(String... args) throws Exception {
            // Custom logic to be executed after the application starts
            System.out.println("Executing command line runner");
        }
    }
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Can you explain the purpose of Stereotype annotations in the Spring Framework ?

Stereotype annotations in the Spring Framework are used to indicate the roles of annotated classes in the application.
These annotations help the Spring container to understand and manage these classes appropriately.

Here are five commonly used Stereotype annotations in Spring:
    1. @Controller:
       - Purpose: Marks a class as a Spring MVC controller.
       - Usage: Used in the presentation layer to handle HTTP requests and generate responses.
    2. @RestController:
       - Purpose: Specialization of `@Controller` for RESTful web services. It combines `@Controller` and `@ResponseBody`.
       - Usage: Used to create RESTful web services that return JSON or XML responses.
    3. @Service:
       - Purpose: Marks a class as a service bean in the business layer.
       - Usage: Used to define business logic and transactional methods.
    4. @Repository:
       - Purpose: Marks a class as a Data Access Object (DAO) component, typically for database operations.
       - Usage: Used in the persistence layer to interact with databases or other data sources.
    5. @Component:
       - Purpose: Generic stereotype annotation for any Spring-managed component.
       - Usage: Used when no more specific stereotype annotation (e.g., `@Controller`, `@Service`) is suitable.

These Stereotype annotations help the Spring container identify and manage different types of components within the application, facilitating dependency injection
and overall application structure. They play a crucial role in achieving a well-organized and modular Spring-based application architecture.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How can you define bean in spring framework ?

In Spring Framework, a bean is an object that is managed by the Spring IoC (Inversion of Control) container. Beans are typically Java objects that are instantiated, assembled,
and managed by the Spring container. In a Spring application, you can define beans using the `@Bean` annotation within a configuration class annotated with `@Configuration`.

    Here's an example of defining a bean using `@Bean` in a Spring configuration class:

    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;

    @Configuration
    public class AppConfig {

        @Bean
        public MyBean myBean() {
            return new MyBean();
        }
    }

    In this example:

    - `@Configuration` indicates that the class contains bean definitions.
    - `@Bean` is used on a method (`myBean()` in this case) to declare a bean. The method name (`myBean`) serves as the bean identifier.
    - The method returns the type of the bean (`MyBean`), and the instance returned by the method becomes the bean managed by the Spring container.

    You can then use this bean in other parts of your application by injecting it through constructor injection, method injection, or field injection. For example:

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;

    @Service
    public class MyService {

        private final MyBean myBean;

        @Autowired
        public MyService(MyBean myBean) {
            this.myBean = myBean;
        }

        // Rest of the service logic using myBean
    }

Here, the `MyService` class uses constructor injection to receive the `MyBean` instance, which is provided by the Spring container.
Note: The `@ComponentScan` annotation or XML configuration is typically used to enable component scanning and discover `@Configuration` classes and `@Component`-annotated classes.
This allows Spring to automatically detect and register beans in the application context.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is dependency injection ?

- Manual Object Creation:
  - Before Spring, in Java, programmers had to manually create objects. For example, if the class `Laptop` needed an object of the `Processor` class,
    it had to be created inside the `Laptop` class.

- Tight Coupling Issue:
  - This manual approach resulted in tight coupling, making the application less flexible and harder to maintain.

- Spring's Solution - Dependency Injection (DI):
  - Spring provides a solution through Dependency Injection.
  - With DI, Spring automatically provides the `Processor` object to the `Laptop` class without the programmer having to create it explicitly.

- Inversion of Control (IoC):
  - DI is a form of Inversion of Control (IoC), where control of object creation is given to Spring.
  - The IoC container in Spring takes care of injecting dependencies at runtime.

- IoC Containers in Spring:
  - Spring has two types of IoC containers: `BeanFactory` and `ApplicationContext`.
  - These containers manage the lifecycle of objects and handle the injection of dependencies, promoting a more modular and maintainable design.

In summary, Dependency Injection in Spring eliminates the need for manual object creation, promoting a loosely coupled and more maintainable application design.
The Inversion of Control principle is implemented through Spring's IoC containers, providing flexibility and ease of development.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How many ways we can perform dependency injection in spring or spring boot ? (fields, contractor, setter)

- Field Injection:
  - Dependencies are injected directly into fields using `@Autowired` annotation.
  - Example: `@Autowired private MyDependency myDependency;`

- Constructor Injection:
  - Dependencies are injected through the constructor of the dependent class.
  - Preferred method for dependency injection.
  - Example:

    @Autowired
    public MyClass(MyDependency myDependency) {
        this.myDependency = myDependency;
    }

- Setter Injection:
  - Dependencies are injected through setter methods of the dependent class.
  - Example:

    @Autowired
    public void setMyDependency(MyDependency myDependency) {
        this.myDependency = myDependency;
    }

- Method Injection:
  - Dependencies are injected through methods other than the constructor or setters.
  - Example:

    @Autowired
    public void init(MyDependency myDependency) {
        this.myDependency = myDependency;
    }
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
where you would choose to use setter injection over constructor injection, and vice versa ? (immutable, partial injection)

- Constructor Injection:
  - Preferred for mandatory dependencies.
  - Better for creating immutable objects.
  - Encourages dependencies to be set once during object creation.
  - Promotes better encapsulation.
  - When you want to avoid forming circular dependencies error (Example: Two bean autowired in each other's classes with constructor injection will give error during run time)

- Setter Injection:
  - Suitable for optional or mutable dependencies.
  - Allows for partial injection or changing dependencies after object creation.
  - Useful when you want to inject dependencies dynamically at different points in the object's lifecycle.
  - Circular dependencies error can be bypass/resolved (Example: Two bean autowired lazily using @Lazy each other's classes with setter injection will not give error during run time)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Can you provide an example of a real-world use case where @PostConstruct is particularly useful? (preprocessing)

- In a Spring application, you may have a bean responsible for setting up a database connection pool. Use @PostConstruct to perform tasks like initializing
  the connection pool, ensuring it's ready for use when the application starts.

- In this case, @PostConstruct ensures that the database connection pool is initialized once the bean is constructed, avoiding issues with uninitialized
  connections during application startup.

- `CommandLineRunner`s run() method is specifically for tasks related to command line processing after the application context is initialized.
- `@PostConstruct` is for general bean initialization tasks, ensuring that a method is called just after the bean is constructed and dependencies are injected.

While `CommandLineRunner` is more geared towards command line-related tasks, `@PostConstruct` is part of the broader bean lifecycle and can be used for any initialization
logic needed for a bean.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How can we dynamically load values in a Spring Boot application? //@Value Environment class

   @Value Annotation:
   - Use `@Value` to inject values directly into Spring beans.
   - Values can come from properties files, environment variables, etc.

   Example:

   @Value("${my.property}")
   private String myProperty;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Can you explain the key differences between YML and properties files, and in what scenarios you might prefer one format over the other?

YAML (YML):
- Human-readable, indentation-based syntax.
- Supports complex data structures like lists and maps.
- Easier to read and write for complex configurations.

Properties File (`.properties`):
- Simple key-value pairs.
- Limited to flat, string-based configuration.
- Widely used in legacy and simple configuration scenarios.

Scenarios:
- YAML (YML):
  - Preferred for complex configurations.
  - Readability is crucial.
  - Spring Boot application.yml is often used.

- Properties File:
  - Suitable for simple, flat configurations.
  - Legacy systems or tools that expect `.properties` format.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is the difference between yml & YAML ?
 -No difference.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
If I will configure same values in both properties then which value will be load in spring boot OR Who will load first properties or yml file ?

 - properties file gets loaded first.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to load External Properties in Spring Boot ? (spring.config.import)

In Spring Boot, external properties can be loaded using the spring.config.import property. This property allows you to specify additional configuration files to be loaded,
extending or overriding the properties defined in the default application.properties or application.yml.

spring.config.import=classpath:custom-config.properties
spring.config.import=file:/path/to/custom-config.properties


spring:
  config:
    import: classpath:custom-config.yml

spring:
  config:
    import: classpath:custom-config.yml,file:/path/to/another-config.properties

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How to map or bind config properties to java Object ? (@ConfigurationProerteis(prefix="")

- For instance, let’s assume we want to send emails using the Gmail SMTP server:
      gmail:
            smtp:
                host: smtp.gmail.com
                port: 587
                username: admin
                password: P@ssW@rd


- @Configuration
  @ConfigurationProperties(prefix = "app.gmail.smtp")
  @Data
  @NoArgsConstructor
          public class GmailSmtpServer {
              private String host;
              private int port;
              private String username;
              private String password;
          }

As we can see, @ConfigurationProperties provides the prefix attribute. It denotes the starting point of the properties binding.

For example, Spring Boot will map app.gmail.smtp.host property to host variable.

Spring Boot relies on setters to do the all the heavy lifting of the mapping. This is why we define them for each field using @Data.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------







How will you resolve bean dependency ambiguity ? //@Qualifier("classname in camelcase") if one interface orderrepo implemented by two orderrepoimpl1 & orderrepoimpl2 class and you @autowired interface name like orderrepo run tim give error
Can we avoid this dependency ambiguity without using @Qualifier ? //yes we can use (from java) @Resource(name="classname in camelcase")//byname...instead of @Qualifier//by type
What is bean scope & Can you explain different type of bean scope ? // singleton*, prototype*, request*, session*, webscoket(per websocket), application (entire webapp)
How to define custom bean scope ?//scerio where i need to create bean for every thread then existing scope will not help. Implmenet scope interface override get and remove method
Can you provide a few real-time use cases for when to choose Singleton scope and Prototype scope ? //singl: caching an instance, Thread saftey db connection pool & db config, appn config like shared resourc across appn & prot: For database repository components that manage a connection to a database and need a new instance per transaction or request. Example: JPA Repositories.
can we inject prototype bean in singleton bean ? if yes what will happen if we inject prototype bean in singleton bean ? // yes we can do it. but the bean with prototype will looese its own scope and behave as singleton scope inherting from the singleton bean. to overcome this instead of autowired prototype of bean you can autowrire application context and get bean from there not recommended way as we are manuling managing life cycle of bean two ways again you can solve this by @Lookup and  ObjectFactory<PrototypeBean>
What is the difference between spring singleton and plain singleton ? //within the jvm singleton for java singleton & scope within the application context for spring singleton
What is the purpose of the BeanPostProcessor interface in Spring, and how can you use it to customize bean initialization and destruction? //  this is used for performing operation before and after bean intialization...implememtn BeanPostProcessor interface and override its two method postprocessbeforeintialization & postprocessafterintialization. example while returing user brean if i want to validate password at the the of initialization itself there we can use it
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Have you worked on Restful webservices ? If yes What all HTTP methods have you used in your project ?
How can you specify the HTTP method type for your REST endpoint?
Scenario : Can you design a rest endpoint , Assume that you have a Product database, and your task is to create an API to filter a list of products by productType ?
Scenario : Design endpoints in a way that takes “productType” as input. If the user provides this input, the endpoint should filter products based on the specified condition. If “productType” is not provided, the endpoint should return all the products. ?
What is the difference between @PathVariable & @RequestParam ? //@PathVariable is mandatory & @RequestParam this is optional and default value can be allowed with this
Why did you use @RestController why not @Controller ? //
How can we deserialize a JSON request payload into an object within a Spring MVC controller ? //@RequestBody
Can we perform update operation in POST http method if yes then why do we need Put Mapping or put http method? //
Can we pass Request Body in GET HTTP Method ?
How can we perform content negotiation (XML/JSON) in Rest endpoint ?
What all status code you have observed in your application ?
How can you customize the status code for your endpoint ? // @ResponseStatus
How can you enable cross origin ?
How can you upload a file in spring ?
How do you maintain versioning for your REST API?
How will you document your rest API ?
How can you hide certain REST endpoints to prevent them from being exposed externally in swagger document? //@Hidden
How will you consume restful API ?
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
How will you handle exceptions in your project ?
How can you avoid defining handlers for multiple exceptions, or what is the best practice for handling exceptions ?
How will you validate or sanitise your input payload ?
How can you populate validation error message to the end users ?
How can you define custom bean validation ?
use case : let’s say you find a bug in production environment and now you want to debug that scenario ,How can you do that from your local ? // spring.profiles.active = dev in appn.prop file
How can you enable a specific environment without using profiles? OR what is the alternative to profiles to achieving same use case ?
What is the difference between @Profile & @ConditioOnXXX ?
What is AOP ?
What is pointcut & join Points in AOP ?
What are different type of advice ?
use case — can I use AOP to evaluate performance of a method or is this possible to design a logging framework to capture request and response body of a method ?
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

JPA and Microservice interview questions needs to be added